/**
 * Maps URL language codes to the directory names used for docs files.
 * Most languages use the same code, but Chinese uses 'zh-Hans' per ISO standard.
 */
const LANG_TO_DOCS_DIR: Record<string, string> = {
  zh: 'zh-Hans',
}

export function docsDir(lang: string): string {
  return LANG_TO_DOCS_DIR[lang] ?? lang
}

export interface DocFrontmatter {
  title: string
  description: string
}

export interface TocEntry {
  id: string
  text: string
  level: number
}

/**
 * Parse YAML frontmatter from a markdown string.
 * Returns the frontmatter fields and the remaining markdown body.
 */
export function parseFrontmatter(markdown: string): { frontmatter: DocFrontmatter; body: string } {
  const match = markdown.match(/^---\r?\n([\s\S]*?)\r?\n---\r?\n([\s\S]*)$/)
  if (!match) {
    return {
      frontmatter: { title: '', description: '' },
      body: markdown,
    }
  }

  const raw = match[1]
  const body = match[2]

  const frontmatter: DocFrontmatter = { title: '', description: '' }
  for (const line of raw.split('\n')) {
    const colonIndex = line.indexOf(':')
    if (colonIndex === -1) continue
    const key = line.slice(0, colonIndex).trim()
    const value = line.slice(colonIndex + 1).trim()
    if (key === 'title') frontmatter.title = value
    if (key === 'description') frontmatter.description = value
  }

  return { frontmatter, body }
}

/**
 * Extract headings from markdown body text to build a table of contents.
 * Only extracts h2 and h3 headings (## and ###).
 */
export function extractHeadings(markdown: string): TocEntry[] {
  const headings: TocEntry[] = []
  const lines = markdown.split('\n')

  for (const line of lines) {
    const match = line.match(/^(#{2,3})\s+(.+)$/)
    if (!match) continue

    const level = match[1].length
    const text = match[2].trim()
    const id = text
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .replace(/\s+/g, '-')

    headings.push({ id, text, level })
  }

  return headings
}

/**
 * Generate a slug-safe id from heading text.
 * Must match the IDs generated by the heading renderer in the docs page.
 */
export function headingToId(text: string): string {
  return text
    .toLowerCase()
    .replace(/[^\w\s-]/g, '')
    .replace(/\s+/g, '-')
}

export interface FaqEntry {
  question: string
  answer: string
}

/**
 * Extract FAQ question/answer pairs from markdown.
 * Looks for H3 headings that end with "?" under an H2 containing "FAQ" or
 * "Frequently Asked Questions" (or localized equivalents).
 * The answer is the paragraph text following the H3 heading.
 */
export function extractFaqEntries(markdown: string): FaqEntry[] {
  const entries: FaqEntry[] = []
  const lines = markdown.split('\n')

  let inFaqSection = false

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i]

    // Detect FAQ section by H2 heading
    if (line.match(/^##\s+/)) {
      const heading = line.replace(/^##\s+/, '').trim()
      inFaqSection = /faq|frequently asked|常见问题/i.test(heading)
      continue
    }

    // Inside FAQ section, look for H3 questions
    if (inFaqSection && line.match(/^###\s+/)) {
      const question = line.replace(/^###\s+/, '').trim()

      // Collect answer paragraphs (non-empty lines until next heading or empty line after content)
      const answerLines: string[] = []
      for (let j = i + 1; j < lines.length; j++) {
        const nextLine = lines[j]
        if (nextLine.match(/^#{2,3}\s+/)) break
        if (nextLine.trim() !== '') {
          answerLines.push(nextLine.trim())
        } else if (answerLines.length > 0) {
          break
        }
      }

      if (answerLines.length > 0) {
        entries.push({ question, answer: answerLines.join(' ') })
      }
    }
  }

  return entries
}
